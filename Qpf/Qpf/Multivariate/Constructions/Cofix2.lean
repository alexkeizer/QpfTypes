import Mathlib.Control.Functor.Multivariate
import Mathlib.Data.PFunctor.Multivariate.Basic
import Mathlib.Data.PFunctor.Multivariate.M
import Mathlib.Data.QPF.Multivariate.Basic

import Qpf.Qpf.Multivariate.Constructions.Cofix
import Qpf.Util


open TypeVec MvFunctor

namespace MvQPF
  variable {n : Nat} (F : TypeFun.{u+1,u+1} (n+1)) [q : MvQPF F]

  /--
    An `F`-coalgebra is a state machine.

    We carefully construct it so that the `Coalgebra` type lives in `Type u + 1`,
    which is also the universe of arguments to `F`.
    This allows us to construct the final coalgebra as a quotient of `Coalgebra`
  -/
  structure Coalgebra (α : TypeVec n) where
    /-- States of the coalgebra -/
    σ : Type u
    /-- Single step unfold -/
    unfold : σ → F (α ::: (ULift.{u+1} σ))

  /--
    A *pointed* `F`-coalgebra is a state machine plus an initial state
  -/
  structure PointedCoalgebra (α : TypeVec n) extends Coalgebra F α where
    /-- The current state -/
    point : σ 
  
  
  namespace PointedCoalgebra
    variable {F} {α : TypeVec n}

    /--
      We can view a `PointedCoalgebra` as a state in the Coalgebra of Coalgebras.
      This function is the `unfold` operation for this Coalgebra of Coalgebras
    -/
    def unfoldRoot (c : PointedCoalgebra F α) : F (α ::: PointedCoalgebra F α) :=
      (id ::: (fun d => ⟨c.toCoalgebra, d.down⟩)) <$$> (c.unfold c.point)

    def bisimilar (c₁ c₂ : PointedCoalgebra F α) : Prop :=
      ∃ (R : c₁.σ → c₂.σ → Prop), 
        R c₁.point c₂.point
        ∧ ∀ {s₁ s₂}, R s₁ s₂ → 
          let ⟨a₁, f₁⟩ := q.repr <| c₁.unfold s₁
          let ⟨a₂, f₂⟩ := q.repr <| c₂.unfold s₂
          ∃ (h : a₁ = a₂), 
            (∀ b, R (f₁ 0 b).down (f₂ 0 <| cast (by rw[h]) b).down)

    

    def bisimilar.iseqv : Equivalence (@bisimilar n F q α) where
      refl  := 
        by
          intro c
          use fun x y => x = y
          apply And.intro
          . rfl
          . intro s₁ s₂ eq
            cases eq
            cases repr (c.unfold s₁)
            simp
      symm  :=
        by
          intro c₁ c₂ ⟨R, hpoint, h⟩
          use fun x y => R y x
          apply And.intro
          . assumption
          . intro s₂ s₁ rel
            specialize h rel
            revert h
            cases repr (c₁.unfold s₁)
            cases repr (c₂.unfold s₂)
            simp only [forall_exists_index]
            rintro ⟨⟩ hb 
            use rfl
            intro b
            apply hb
          
      trans :=
        by
          intro c₁ c₂ c₃ ⟨R₁, hpoint₁, h₁⟩ ⟨R₂, hpoint₂, h₂⟩
          use fun x z => ∃y, R₁ x y ∧ R₂ y z
          apply And.intro
          . use c₂.point
            exact And.intro hpoint₁ hpoint₂
          . intro s₁ s₃
            rintro ⟨s₂, ⟨hR₁, hR₂⟩⟩
            specialize h₁ hR₁
            specialize h₂ hR₂
            revert h₁ h₂
            rcases repr (c₁.unfold s₁) with ⟨a₁, f₁⟩
            rcases repr (c₂.unfold s₂) with ⟨a₂, f₂⟩
            rcases repr (c₃.unfold s₃) with ⟨a₃, f₃⟩
            simp only [forall_exists_index]
            rintro ⟨⟩ hb₁ ⟨⟩ hb₃
            use rfl
            intro b
            specialize hb₁ b
            specialize hb₃ b
            simp only [cast_eq] at hb₁ hb₃ |-
            exact ⟨(f₂ 0 b).down, hb₁, hb₃⟩

    def bisimilar.setoid : Setoid (PointedCoalgebra F α)  where
      r := (@bisimilar n F q α)
      iseqv := iseqv
  end PointedCoalgebra



  /--
    States of the final coalgebra are equivalence classes of bisimilar, pointed coalgebras
  -/
  def FinalCoalgebra (α : TypeVec n) : Type (u + 1)
    := Quotient (@PointedCoalgebra.bisimilar.setoid n F q α) 

  namespace FinalCoalgebra
    variable {F}

    def mk : PointedCoalgebra F α  → FinalCoalgebra F α 
      := Quotient.mk _

    def unfold : FinalCoalgebra F α → F (α ::: (FinalCoalgebra F α)) :=
      Quotient.lift 
        (fun c => (id ::: mk) <$$> c.unfoldRoot)
        (by 
          intro a b (eqv : a.bisimilar b)
          rcases eqv with ⟨R, points_related, is_bisim⟩
          specialize is_bisim points_related
          simp only [PointedCoalgebra.unfoldRoot]
          -- intro ⟨⟨σ₁, unfold₁⟩, p₁⟩ ⟨⟨σ₂, unfold₂⟩, p₂⟩ eqv
          simp only [MvFunctor.map, TypeVec.id, mk, appendFun]
          

        )

  end FinalCoalgebra

  namespace PointedCoalgebra

    -- def finalCoalgebra : Pointed

    /--
      Produce the full, non-wellfounded tree that is generated by this coalgebra
    -/
    def generate (c : PointedCoalgebra F α) : Cofix F α :=
      Cofix.corec (fun s => c.unfold s.down) (ULift.up c.point)

    
    def ofCofix (c : Cofix F α) : PointedCoalgebra F α :=
      _


  end PointedCoalgebra

end MvQPF