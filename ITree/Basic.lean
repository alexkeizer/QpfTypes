import Qpf
import Mathlib.Data.QPF.Multivariate.Constructions.Sigma

#check MvPFunctor

/-!
# Interaction Trees

We define interaction trees, a coinductive data-structure used for giving
semantics of side-effecting, possibly non-terminating, programs

[1] https://arxiv.org/abs/1906.00046
[2] https://github.com/DeepSpec/InteractionTrees
-/

/-
## Hacks / Workarounds

We'd like to define interaction trees as follows:
```
codata ITree (ε : Type → Type) ρ where
  | ret (r : ρ)
  | tau (t : ITree ε ρ)
  | vis {α : Type} (e : ε α) (k : α → ITree ε ρ)
```
Unfortunately, `vis` in that definition is a dependent arrow in disguise,
and dependent arrows are currently not supported by the framework yet.

What is supported, though, are sigma types, as in the following, equivalent,
definition
```
codata ITree (ε : Type → Type) ρ where
  | ret (r : ρ)
  | tau (t : ITree ε ρ)
  | vis (e : Σ α : Type, ε α × α → ITree ε ρ)
```

Unfortunately, this, too yields an error, so for now we settle for fixing a
particular input type `α`, by making `α` a parameter of the type.
-/

set_option trace.QPF true
codata ITree (α : Type) (ι : α → Type) (ε : α → Type) ρ where
  | ret (r : ρ)
  | tau (t : ITree ε ρ)
  | vis (e : Σ a : α, ε a × (ι a) → ITree ε ρ)

inductive ITree2.Shape ρ ι ν
  | ret (r : ρ)
  | tau (t : ι) -- ι = ITree ε ρ
  | vis (e : ν) -- ν = Σ α : Type, ε α × α → ITree ε ρ

-- qpf F ε ρ ι ν    = (Σ α : Type, ε α × α → ι)

-- qpf F (α : Type) ε ρ ι ν    = Sigma G

qpf G (α : Type) (ε : Type → Type) ρ ι ν := ε α × (α → ι)

#check G
#check Sigma

def Gs {α : Type} (f : α → Type) (ε : Type _ → Type _) : TypeFun 3 :=
  MvQPF.Sigma (A := α) (fun a => TypeFun.ofCurried (n:=3) <| G (f a) ε)


#print ITree.Shape
#print ITree.Shape.P
#print MvQPF.Sigma

namespace ITree

/-- the corecursion principle on itrees is the low-level way of defining a
cotree, as being generated by some transition function `f`
from initial state `b` -/
def corec {β α ε ρ : Type} (f : β → ITree.Base α ε ρ β) (b : β) : ITree α ε ρ :=
  MvQPF.Cofix.corec (F := TypeFun.ofCurried ITree.Base) f b

/-- `ITree.spin` is an infinite sequence of tau-nodes. -/
def spin : ITree α ε ρ :=
  corec (fun () => .tau ()) ()

end ITree
